{"content":"<p>从图书馆翻过各种JS的书之后，对<strong>作用域/执行环境/闭包</strong>这些概念有了一个比较清晰的认识。</p>\n<h1 id=\"栗子说明一切\"><a href=\"#栗子说明一切\" class=\"headerlink\" title=\"栗子说明一切\"></a>栗子说明一切</h1><h2 id=\"第一个栗子\"><a href=\"#第一个栗子\" class=\"headerlink\" title=\"第一个栗子\"></a>第一个栗子</h2><p>来看一个来自<a href=\"http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#execution-context\" target=\"_blank\" rel=\"noopener\">ECMA-262</a>的栗子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"number\">20</span>;</span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> z = <span class=\"number\">30</span>;</span><br><span class=\"line\">    <span class=\"comment\">// \"x\" and \"y\" are \"free variables\"</span></span><br><span class=\"line\">    <span class=\"comment\">// and are found in the next (after</span></span><br><span class=\"line\">    <span class=\"comment\">// bar's activation object) object</span></span><br><span class=\"line\">    <span class=\"comment\">// of the bar's scope chain</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x + y + z);</span><br><span class=\"line\">  &#125;)();</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>我们可以用下图展现上面的例子(父变量对象存储在函数的<code>Scope</code>属性内)<br><img src=\"http://ww2.sinaimg.cn/large/724c9a82jw1f2qt3du7k5j20650buaa5.jpg\" alt=\"scope-chain.png\"></p>\n<p>首先，可以很容易的理解到一个事实：在从控制台输出<code>x+y+z</code>的时候，<code>x</code>和<code>y</code>是在<code>bar()</code>函数中的作用域链中<code>bar()</code>的活动对象之下找到的。实际上，<code>foo()</code>函数和<code>bar()</code>函数在执行的时候，他们的<code>scope</code>属性就已经确定了，他们的<code>scope</code>属性<strong>确定为他们外层的变量对象(VO)的集合</strong>。从图中可知，内存结构可能是这样的：<br><a id=\"more\"></a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// foo的scope属性是global的VO</span></span><br><span class=\"line\">foo.[<span class=\"string\">\"[[Scope]]\"</span>] = &#123; global.[<span class=\"string\">\"Variable Object\"</span>] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bar的scope属性是foo的AO和global的VO的集合</span></span><br><span class=\"line\">bar.[<span class=\"string\">\"[[Scope]]\"</span>] = &#123;foo.[<span class=\"string\">\"Activation Object\"</span>], global.[<span class=\"string\">\"Variable Object\"</span>]&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"第二个栗子\"><a href=\"#第二个栗子\" class=\"headerlink\" title=\"第二个栗子\"></a>第二个栗子</h2><p>这个例子来自《高性能Javascript》<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局范围定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = num1 + num2;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当<code>add()</code>函数创建的时候，它的<code>scope</code>属性被确定为全局对象的VO，这个全局对象的VO可能包括<code>window</code>/<code>navigator</code>/<code>document</code>之类等等。关系如图：<br><img src=\"http://ww1.sinaimg.cn/large/724c9a82jw1f2qt3exrs1j20jc05ddhi.jpg\" alt=\"add_chain\"><br>这个<code>scope</code>属性很特别，他是<strong>静态的</strong>，在函数创建的时候便能确定。图片中的作用域链，<strong>是全局执行环境中的作用域链</strong>。而在函数执行的时候，书中说道：</p>\n<blockquote>\n<p>每个执行上下文都有自己的作用域链，用于解析标识符。当执行上下文被创建的时候，<strong>它的作用域链初始化为当前运行函数的<code>scope</code>属性中的对象</strong>。这些值按照他们出现在函数中的顺序，被复制到执行上下文的作用域链中。这个过程一旦完成，一个被称为“活动对象(AO)”的新对象就为执行上下文创建好了。活动对象作为函数运行时的变量对象，包含了所有的局部变量，命名参数，参数集合以及<code>this</code>。<strong>然后此活动对象被推入作用域链的最前端</strong>。</p>\n</blockquote>\n<p>可以了解到，<strong>作用域链是个链表，是在函数执行的时候才存在的，也就是函数创建执行环境的时候才开始存在的</strong>，它先把这个函数的静态属性<code>scope</code>属性中的所有变量对象按照顺序复制到作用域链（所以这样就不会担心作用域链嵌套的问题），然后创建AO放在作用域链顶部“0号位”。例如再执行代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> total = add(<span class=\"number\">5</span>, <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure></p>\n<p>图片如下图：<br><img src=\"http://ww2.sinaimg.cn/large/724c9a82jw1f2qt3ehbq1j20jc0bhdgo.jpg\" alt=\"add_exc\"></p>\n<p>所以，我们也可以得到一个惊人的结论：</p>\n<p><strong>函数作用域链 = 活动对象(AO) + <code>scope</code>属性</strong></p>\n<h1 id=\"关键的来了\"><a href=\"#关键的来了\" class=\"headerlink\" title=\"关键的来了\"></a>关键的来了</h1><p>这个结论中：活动对象(AO)是临时的，动态的，独一无二的。<code>scope</code>属性是静态的，确定的。</p>\n<p>所以说，<strong>函数的作用域链，是函数执行的时候动态创建的，但是它又是基于静态词法的环境(<code>scope</code>属性)</strong>。所谓“动态创建”，是指在函数执行的时候，先创建之前没有的作用域链，再创建活动对象，然后活动对象推入作用域链最前端；所谓“基于静态的词法环境”是指函数定义的时候，这个函数本是没有作用域链的，有的只有<code>scope</code>属性，而这个属性指向了这个函数外部的执行环境，而这个外部的执行环境拥有作用域链（因为这是外部创建外部的执行环境才拥有作用域链的，这样有一点递归的味道）。<del>P.S.其实有的版本也说，作用域链的确定应该是在活动变量创建完成之后的，这个有待钻研。</del><br>P.S 在ES5规范文档中，进入函数代码的流程：<br><img src=\"http://ww4.sinaimg.cn/large/724c9a82jw1f2qzii6t8yj20of07q759.jpg\" alt=\"hanshudaima\"></p>\n<h1 id=\"扯到变量提升\"><a href=\"#扯到变量提升\" class=\"headerlink\" title=\"扯到变量提升\"></a>扯到变量提升</h1><p>变量提升的本质就是函数在创建执行环境中的变量对象的时候，记录下了函数声明，变量和参数等等。具体参见<a href=\"http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/\" target=\"_blank\" rel=\"noopener\">深入理解Javascript之执行上下文(Execution Context)</a>，下面是片段：</p>\n<blockquote>\n<ul>\n<li>建立Variable Object对象顺序：</li>\n</ul>\n<ol>\n<li><p>建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值</p>\n</li>\n<li><p><strong>检查当前上下文中的函数声明：</strong> 每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用。如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。</p>\n</li>\n<li><p><strong>检查当前上下文中的变量声明：</strong> 每找到一个变量的声明，就在variableObject下，用变量名建立一个属性，属性值为undefined。如果该变量名已经存在于variableObject属性中，直接跳过(防止指向函数的属性的值被变量属性覆盖为undefined)，原属性值不会被修改。</p>\n</li>\n</ol>\n</blockquote>\n<h1 id=\"扯到闭包\"><a href=\"#扯到闭包\" class=\"headerlink\" title=\"扯到闭包\"></a>扯到闭包</h1><p>闭包，在离散数学中指的是满足性质A的一个最小关系集R，这可以理解这个关系集R，在性质A上封闭。<strong>闭包不是一种魔法</strong>，虽然可以通过闭包扯得很远很远，通过函数的作用域链的组成为AO+<code>scope</code>属性，为快速理解闭包中变量引用来自哪里提供了思路————<strong>没那么复杂，就直接再执行的函数定义处上看就行了</strong>。把函数定义的作用域看成是函数执行的作用域。这也是词法作用域迷人的地方。</p>\n<h1 id=\"Show-Me-the-Code\"><a href=\"#Show-Me-the-Code\" class=\"headerlink\" title=\"Show Me the Code\"></a>Show Me the Code</h1><p>说了那么多，有代码才是王道，毕竟“Talk is cheap”。</p>\n<h2 id=\"“面向对象”一般的编程：实现封装\"><a href=\"#“面向对象”一般的编程：实现封装\" class=\"headerlink\" title=\"“面向对象”一般的编程：实现封装\"></a>“面向对象”一般的编程：实现封装</h2><p>这段代码来自<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"noopener\">MDN-用闭包模拟私有方法</a>，有更改<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Counter = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> privateCounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeBy</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">    privateCounter += val;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    increment: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dis</span>) </span>&#123;</span><br><span class=\"line\">      changeBy(dis);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    decrement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dis</span>) </span>&#123;</span><br><span class=\"line\">      changeBy(-dis);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    value: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> privateCounter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Counter.value()); <span class=\"comment\">// 0</span></span><br><span class=\"line\">Counter.increment(<span class=\"number\">1</span>);</span><br><span class=\"line\">Counter.increment(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Counter.value()); <span class=\"comment\">// 3</span></span><br><span class=\"line\">Counter.decrement(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Counter.value()); <span class=\"comment\">// -2</span></span><br></pre></td></tr></table></figure></p>\n<p>返回的是一个对象，这个对象有三个属性，都是函数。而且这三个函数的<code>scope</code>属性都是指向一个集合，这个集合包括外层匿名函数的的AO，和全局变量的VO。分析一下<code>Counter.value()</code>这个调用：<code>value</code>这个属性对应的匿名函数定义的时候，它的<code>scope</code>属性确定，这个是词法作用域的特性，这个<code>scope</code>属性指向的是外部所有变量对象的集合（也就是上句说的那个集合）。在最后调用<code>Counter.value()</code>的时候，创建<strong>先构建作用域链，再创建执行环境</strong>，再创建执行环境的时候发现了一个变量标识符<code>privateCounter</code>。好，接下来在函数体内找找这个对应的值，找不到；到外层的函数，也就是那个<code>Counter</code>对应的匿名函数，诶找到了！好，将这个标识符和这个量“关联起来”。<br>结果，这样下来，返回的这个对象就类似于面向对象变成中的“外部接口”，而没有被返回的那部分(也就是代码中的<code>var privateCounter</code>和<code>function changeBy</code>)则成了“私有的”，无法从外部直接访问。这样的闭包模拟了数据的封装和隐藏，一股熟悉而浓郁的<code>C++</code>味道袭来。当然，这样用的确不错，但是关乎性能方面，MDN这样推荐道：</p>\n<blockquote>\n<p>如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。<br>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用，方法都会被重新赋值一次（也就是说，为每一个对象的创建）。</p>\n</blockquote>\n<h2 id=\"执行环境到底是怎么建立的？\"><a href=\"#执行环境到底是怎么建立的？\" class=\"headerlink\" title=\"执行环境到底是怎么建立的？\"></a>执行环境到底是怎么建立的？</h2><p>下面片段来自<a href=\"http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/\" target=\"_blank\" rel=\"noopener\">深入理解Javascript之执行上下文(Execution Context)</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> a = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">privateB</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"number\">22</span>);</span><br></pre></td></tr></table></figure></p>\n<p>在调用<code>foo(22)</code>的时候，建立阶段如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fooExecutionContext = &#123;</span><br><span class=\"line\">   variableObject: &#123;  <span class=\"comment\">// 变量对象</span></span><br><span class=\"line\">       <span class=\"built_in\">arguments</span>: &#123;</span><br><span class=\"line\">           <span class=\"number\">0</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">           length: <span class=\"number\">1</span></span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       i: <span class=\"number\">22</span>, <span class=\"comment\">// 形式参数声明在函数声明前</span></span><br><span class=\"line\">       c: pointer to <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>) // 注意，函数声明在变量声明前</span></span><br><span class=\"line\"><span class=\"function\">       <span class=\"title\">a</span>: <span class=\"title\">undefined</span>,</span></span><br><span class=\"line\"><span class=\"function\">       <span class=\"title\">b</span>: <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\">   &#125;,</span></span><br><span class=\"line\"><span class=\"function\">   // 作用链和变量对象顺序问题，有待钻研，<span class=\"title\">T</span>.<span class=\"title\">T</span></span></span><br><span class=\"line\"><span class=\"function\">   // 在官方文档中，貌似是作用域链先被创建(<span class=\"params\">而且被称作词法环境组件</span>)</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"title\">scopeChain</span>: </span>&#123; ... &#125;,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由此可见，在建立阶段，除了arguments，函数的声明，以及参数被赋予了具体的属性值，其它的变量属性默认的都是undefined。一旦上述建立阶段结束，引擎就会进入代码执行阶段，这个阶段完成后，上述执行上下文对象如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fooExecutionContext = &#123;</span><br><span class=\"line\">   variableObject: &#123;</span><br><span class=\"line\">       <span class=\"built_in\">arguments</span>: &#123;</span><br><span class=\"line\">           <span class=\"number\">0</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">           length: <span class=\"number\">1</span></span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       i: <span class=\"number\">22</span>,</span><br><span class=\"line\">       c: pointer to <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">       <span class=\"title\">a</span>: '<span class=\"title\">hello</span>',</span></span><br><span class=\"line\"><span class=\"function\">       <span class=\"title\">b</span>: <span class=\"title\">pointer</span> <span class=\"title\">to</span> <span class=\"title\">function</span> <span class=\"title\">privateB</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">   &#125;,</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"title\">scopeChain</span>: </span>&#123; ... &#125;,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们看到，<strong>只有在代码执行阶段，变量属性才会被赋予具体的值</strong>。</p>\n<h1 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h1><ul>\n<li>分析代码的时候，务必回看函数的定义，毕竟人家函数是<strong>一等贵族</strong>。</li>\n<li>记住<strong>函数作用域链 = (动)活动对象(AO) + (静)<code>scope</code>属性</strong>。</li>\n<li>执行环境结构：<img src=\"http://ww2.sinaimg.cn/large/724c9a82jw1f2qt3dkqtpj209g06xq2x.jpg\" alt=\"ec\"></li>\n<li>执行环境创建后，才开始执行代码，变量对象才开始被赋值</li>\n<li>变量提升 ==&gt; 变量对象的创建</li>\n<li>闭包 ===&gt; 作用域链中静态的部分，即<code>scope</code>属性</li>\n</ul>\n<h1 id=\"官方文档的补充\"><a href=\"#官方文档的补充\" class=\"headerlink\" title=\"官方文档的补充\"></a>官方文档的补充</h1><p><img src=\"http://ww2.sinaimg.cn/large/724c9a82jw1f2qzlxkfc3j20qc04rgm6.jpg\" alt=\"执行环境\"><br>我的理解：词法环境组件 ≈ 作用域；变量环境组件 ≈ 变量对象；<br><img src=\"http://ww3.sinaimg.cn/mw690/724c9a82jw1f2qzly0iupj20dh086gm2.jpg\" alt=\"全局\"><br>以初始化全局代码的时候，貌似是创建变量对象在先。(这样有什么特殊的意义吗？)</p>\n","post_id":"cjgghugfb0006msxeu8bl0o0j"}